a = []
# добавление в конец
a.append(1) 
a.append(2)
# очистка списка
a.clear()
# копирование
arr = [1, 2, 3]
old_arr = arr.copy()
# подсчет количества входлений указанного элемента
arr = ['g', 2,5,8,8,]
print(arr.count(8))
# добавление списка в список
arr2 = ['abc','kjsdfhgkdfjhg']
arr.extend(arr2)

# поиск первого включения. аналог ВПР
users = [1,2,25,5,8,9,35345345]
dates = ['2022-01-15', '2025-78-6', '2205-11-09']
dates[users.index(25)] # ищем номер элемента '25' в users[] и по нему берем из dates

# добавить элемент в список с помощью insert в нужное место
arr = ['g', 2,5,8,8,]
arr.insert(0,1000) #можно нарпимер .insert(int(len(arr)/2), 1000)
print (arr)

# удалить элемент из списка с помощью pop и remove
print(arr)
print(arr.pop(0)) # pop возвращает заданный элемент и удаляет его из списка
print(arr)
arr.remove(8) # remove удаляет первый найденый заданный элемент из списка
print(arr)

#Как переворачивать и сортировать списки с помощью методов reverse и sort
arr = [1,2,3,4,5,6,7,-8]
arr.reverse() # меняется переменная!!!!
print(arr)
arr.sort()
print(arr)

#Как проверить наличие элемента в списке с помощью оператора in
arr = [1,2,3,4,5,6,7,-8]
three  = 3
three in arr

# индексация и срезы
arr = [1,2,3,4,5,6,['c','d']]
arr[6] #вернет список ['c','d']
arr[0:4]  # срез с 1 по 3. не забыть про шаг при необходимости [z:x:y]

# КАК перевернуть список
arr[::-1] #не меняется переменная

# сложная сортировка
arr_str = ['aa', 'ab', 'ba', 'aa']
arr_str.sort # только один тип данных

# кортежи - неизменяемый список
a = (2, )
a = tuple() #пустой кортеж
a = tuple('abcde') #получаем кортеж из отдельный элементов

# кортеж из списка
a = []
a.extend('abcde')
b = tuple(a)

#распаковка
tup = (1, 'a', True)
num, st, flag = tup
print(num, st, flag)


# множества (не упорядочное, только уникальные элементы)
s = {-100, 'b', 5, 1000, 0, -3, True, 'abc'}
print(s)
s = set() # пустое множество

# проверка на дубликаты
s = set(a) # делаем множество из списка

# можно избавляться от дубликатов
s = set(a)
a = list(s)

s.add(1000) #добавление В любое место
s.discard(1000) # удаление

s1 = {1,2,3,4,5}
s2 = {1,2,7,8,9}
s3 = {1,2,3,}
s4 = {100, 1000}
s1.intersection(s2) #пересечение (общие элементы)
s1.isdisjoint(s2) # наличие пересечение (true - нет общих элементов, false - есть общие элементы) 
s1.issuperset(s3) # входит ли s3 d s1 одно множество в другое полностью
s3.issubset(s1) # является ли подможеством
s1.union(s2) #объединение только одинаковые элементы

# словари - ключ:значение
d = {}
d = {
    'a': 1,
    'b': [1, 2, 3],
    'c': 'abcde'
}
d1 = dict([(1, 'a'), (2, 'b')])
d1['a'] = 123 # добавили пару 'a': 123

d1.clear() #очистка
d1[2] # получение по ключу
d1.get(2) # тоже но если нет ключа не выдает ошибку. а просто ничего не возвращает
d1.get(1000, -1) # тоже но если нет ключа не выдает ошибку. возвращает заданный ответ
d1.items() # пары ключ:значение
d1.keys() # ключ
d1.values() #значения
d.update(d1) # добавление d1 в d. при этом одинаковые ключи перезаписываются
d | d1 # добавление d1 в d. при этом одинаковые ключи перезаписываются
d1.pop(1) #возвращение и удаление
d1.popitem() # #возвращение и удаление последнего добавленого
del d1[1] #удаление по ключу

